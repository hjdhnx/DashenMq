#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 4.23a
#  in conjunction with Tcl version 8.6
#    Jun 03, 2019 11:34:24 PM CST  platform: Windows NT
#    Jun 22, 2019 01:18:43 PM CST  platform: Windows NT
#    Jun 22, 2019 02:43:16 PM CST  platform: Windows NT
#    Jun 22, 2019 06:04:09 PM CST  platform: Windows NT
#    Jun 22, 2019 07:48:12 PM CST  platform: Windows NT

import sys
import time
import paho.mqtt.client
import base64
from platform import architecture as showsystem
import platform
from threading import Thread, Timer, activeCount
from playsound import playsound
import dashenMQ_new_res as myres
from random import randint
import os
import wave
import pyaudio
from contextlib import closing

mqtt = paho.mqtt.client

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk
    from tkinter.messagebox import *
    from tkinter.filedialog import *
try:
    import ttk

    py3 = False
except ImportError:
    import tkinter.ttk as ttk

    py3 = True

def set_Tk_var():
    global tch50
    tch50 = tk.StringVar()
    global entrytv_clientname
    entrytv_clientname = tk.StringVar(value="windows")
    global entrytv_clientid
    entrytv_clientid = tk.StringVar(value="dashen-MQTT-V1_5")
    global tch68
    tch68 = tk.StringVar()
    global combobox_servertype
    combobox_servertype = tk.StringVar(value="EMQ")
    global combobox_mqsl
    combobox_mqsl = tk.StringVar(value="tcp")
    global combobox_mqport
    combobox_mqport = tk.StringVar(value=1883)
    global combobox_mqip
    combobox_mqip = tk.StringVar(value="118.25.210.158")
    global combobox_username
    combobox_username = tk.StringVar(value="dashen")
    global combobox_pwd
    combobox_pwd = tk.StringVar(value="123456")
    global tch76
    tch76 = tk.StringVar()
    global varperson
    varperson = tk.StringVar(value="小燕子")
    global vardelay
    vardelay = tk.StringVar(value="300")
    global combobox_sendtopic
    combobox_sendtopic = tk.StringVar(value="达神")
    global combobox_sendqos
    combobox_sendqos = tk.StringVar(value=0)
    global tch97
    tch97 = tk.StringVar()
    global combobox_sendtype
    combobox_sendtype = tk.StringVar(value="string")
    global combobox_subtopic
    combobox_subtopic = tk.StringVar(value="达神")
    global combobox_subqos
    combobox_subqos = tk.StringVar(value=0)
    global combobox_area
    combobox_area = tk.StringVar(value="北京")
    global combobox_tqtime
    combobox_tqtime = tk.StringVar(value="600")
    global combobox_website
    combobox_website = tk.StringVar()
    global combobox_newstime
    combobox_newstime = tk.StringVar(value="600")
    global combobox_lowtem
    combobox_lowtem = tk.StringVar()
    global combobox_temtime
    combobox_temtime = tk.StringVar(value="600")
    global tch69
    tch69 = tk.StringVar()
    global combobox_hightem
    combobox_hightem = tk.StringVar()
    global tch72
    tch72 = tk.StringVar()
    global combobox_deftem
    combobox_deftem = tk.StringVar()
    global spinbox_setspd
    spinbox_setspd = tk.StringVar()
    global spinbox_setpit
    spinbox_setpit = tk.StringVar()
    global spinbox_setvol
    spinbox_setvol = tk.StringVar()
    global spinbox_setper
    spinbox_setper = tk.StringVar()
    global tch58
    tch58 = tk.StringVar(value=1)
    global varcheck_delyuyin
    varcheck_delyuyin = tk.StringVar(value=1)
    global list_xiazai
    list_xiazai = tk.StringVar()
    global tpb_send
    tpb_send = tk.IntVar(value=100)
    global labletv_jindu
    labletv_jindu = tk.StringVar()
    labletv_jindu.set('100%')
    global entrytv_filepath
    entrytv_filepath = tk.StringVar()

    global tch44
    tch44 = tk.StringVar(value=1)
    global spinbox_luyintime
    spinbox_luyintime = tk.StringVar()
def btn_luyin():
    global yuyin_flag
    if w.Button_luyin.cget("text") == "开启录音":
        yuyin_flag = True
        w.Button_luyin.configure(text='''停止录音''')
        w.Button_luyin.configure(background='''red''')

        # thread_it(luying)
        def dingshiyulin():
            luyin(path="res/luyin/myluyin.wav",long=int(spinbox_luyintime.get()))
            yuyin_flag = False
            w.Button_luyin.configure(text='''开启录音''')
            w.Button_luyin.configure(background='''#78C300''')
        thread_it(dingshiyulin)
    else:
        yuyin_flag = False
        w.Button_luyin.configure(text='''开启录音''')
        w.Button_luyin.configure(background='''#78C300''')
def btn_listen():
    thread_it(playaudio,"res/luyin/myluyin.wav")
    # playaudio("res/luyin/myluyin.wav")

def btn_sendluyin():
    if w.Button_connect.cget("text") == "开始连接":
        showwarning("警告", "请先连接mqtt服务器后再进行操作！")
        return
    w.Button_senluyin.configure(state="disabled")
    def now():
        topic = varperson.get()
        payload = baseluyin(inputpath="res/luyin/myluyin.wav")
        print("录音内容:",payload)
        qos = 0
        on_publish(topic, payload, qos)
        time.sleep(int(spinbox_luyintime.get())*2)
        w.Button_senluyin.configure(state="normal")
    thread_it(now)
def thread_it(func, *args):
    t = Thread(target=func, args=args)
    t.setDaemon(True)
    t.start()

def btn_addsub():
    subtopic = w.TCombobox_subtopic.get()
    subqos = int(w.TCombobox_subqos.get())
    t = w.Scrolledtreeview1.get_children()
    topiclist = []
    for i in t:
        topic, qos = w.Scrolledtreeview1.item(i, 'values')
        topiclist.append(topic)
    if not subtopic in topiclist:
        print("新增订阅%s" % subtopic)
        order = len(t)
        w.Scrolledtreeview1.insert(parent='', index=order, text=order, values=(subtopic, subqos))
        on_subscribe(subtopic, subqos)
    else:
        showinfo("提示", "主题已存在，请勿重复添加！\n若需要更改订阅属性，请删除后重新订阅")

def btn_cancelsub():
    for item in w.Scrolledtreeview1.selection():
        item_text = w.Scrolledtreeview1.item(item, "values")
        # print(item_text)
        # print(item_text[0:2])  # 输出所选行的值
        unsubtopic = item_text[0]
        Unsub(unsubtopic)
        w.Scrolledtreeview1.delete(item)
        print("成功退阅主题:%s" % unsubtopic)
        w.Scrolledtext1.insert(tk.END, "成功退阅主题: “%s”  ！\n" % unsubtopic)

def btn_clearmsg():
    w.Scrolledtext1.delete(1.0, tk.END)

def btn_clearsub():
    x = w.Scrolledtreeview1.get_children()
    for item in x:
        item_text = w.Scrolledtreeview1.item(item, "values")
        unsubtopic = item_text[0]
        w.Scrolledtreeview1.delete(item)
        Unsub(unsubtopic)
        print("成功退阅主题:%s" % unsubtopic)
        w.Scrolledtext1.insert(tk.END, "成功退阅主题: “%s”  !\n" % unsubtopic)

def btn_randomgerner():
    client_id = "达神MQ-" + time.strftime('%Y%m%d%H%M%S', time.localtime(time.time()))
    entrytv_clientid.set(client_id)

def btn_readhistory():
    showinfo("提示", "历史消息为空！")

def btn_savemsg():
    msg = w.Scrolledtext1.get(1.0, tk.END)
    if msg.replace("\n", "").replace(" ", "") != "":
        print(msg)
    else:
        showwarning("警告", "消息为空，无法入库！")
    # savepath = asksaveasfilename(defaultextension=".%s" %"png",filetypes=[("file",".%s"%"png")],initialfile="1.%s"%"png",title="选择路径并设置你要保存的文件名",)
    # print(savepath)

def btn_savefiles():
    # filecode = w.Scrolledtext1.get(1.0,tk.END)
    global write_data
    filecode = write_data
    if filecode.startswith("filecode"):
        filetend = filecode.split('"')[0].split("@")[2].replace("=", "").replace(" ", "")
        # print(filetend)
        filename = filecode.split('"')[0].split("@")[1]
        filecontent = filecode.split(" ")[2]
        # print(filecontent)
        savepath = asksaveasfilename(defaultextension=".%s" % filetend, filetypes=[("file", ".%s" % filetend)],
                                     initialfile="%s.%s" % (filename, filetend), title="选择路径并设置你要保存的文件名")
        if savepath != "":
            # print(savepath)
            tmp = open(savepath, "wb+")
            content = base64.b64decode(filecontent)
            # print(content)
            tmp.write(content)
            tmp.close()
            write_data = ""
    else:
        showerror("错误", "文本域未包含有效的文件数据！\n你上一条可保存文件已保存完毕，目前暂无消息")

def btn_savesettings():
    clinetname = entrytv_clientname.get()
    clinetid = entrytv_clientid.get()
    servertype = combobox_servertype.get()
    mqsl = combobox_mqsl.get()
    mqip = combobox_mqip.get()
    mqport = int(combobox_mqport.get())
    username = combobox_username.get()
    pwd = combobox_pwd.get()
    json = {"clinetname": clinetname, "clinetid": clinetid, "servertype": servertype, "mqsl": mqsl, "mqip": mqip,
            "mqport": mqport, "username": username, "pwd": pwd}
    print(json)
    showinfo("提示", "保存成功!数据为:\n{}".format(json))

def btn_send():
    w.Button_publish.configure(state="disabled")  # 发送按下，按钮变灰，处理后变灰正常
    sendtopic = w.TCombobox_sentopic.get()
    sendqos = int(w.TCombobox_senqos.get())
    sendtype = w.TCombobox_sendtype.get()
    global sendfile
    if sendfile.replace("\n", "").replace("\t", "") == "":
        content = w.Text_sendmsg.get(1.0, tk.END).replace("\n", "\t")
        if content.replace("\t", "") != "":
            print(sendtopic, sendqos, sendtype)
            on_publish(sendtopic, content, sendqos)
            w.Button_publish.configure(state="normal")
    else:
        print(sendfile)
        on_publish(sendtopic, sendfile, sendqos)
        sendfile = ""
        w.Text_sendmsg.delete(1.0, tk.END)
        w.Button_publish.configure(state="normal")

def btn_sendback():
    index = w.Text_sendmsg.index("insert")
    row = index.split(".")[0]
    col = index.split(".")[1]
    begin = int(col) - 1
    if begin < 0:
        begin = 0
    begin_index = row + "." + str(begin)
    w.Text_sendmsg.delete(begin_index, index)

def btn_sendclear():
    w.Text_sendmsg.delete(1.0, tk.END)

def get_filePath_fileName_fileExt(fileUrl):  # 获取文件上级目录,文件名称，文件后缀
    filepath, tmpfilename = os.path.split(fileUrl)
    shotname, extension = os.path.splitext(tmpfilename)
    return filepath, shotname, extension

def btn_selectfile():
    sendtype = w.TCombobox_sendtype.get()
    if sendtype == "file":
        fpath = askopenfilename()
        entrytv_filepath.set(fpath)
        if fpath != "":
            _, fname, tp1 = get_filePath_fileName_fileExt(fpath)
            form = tp1[1:]
            print(form)
            open_file = open(fpath, "rb")
            b64str = base64.b64encode(open_file.read())
            open_file.close()
            global write_data, sendfile
            sendfile = 'filecode@%s@%s = "%s"' % (fname, form, b64str)
            sendfile = sendfile.replace("b'", "").replace("'", "")
            # write_data = "%s"%(b64str)
            f = open("file.txt", "w+")
            f.write(sendfile)
            f.close()

            # w.Scrolledtext1.delete(1.0, tk.END)
            # w.Scrolledtext1.insert(tk.END, "收到一个%s格式的文件,现在点击保存文件可以将其储存！\n"%form)
            def insert():
                w.Text_sendmsg.insert(tk.END, sendfile)

            # thread_it(insert)
            # insert()
            w.Text_sendmsg.delete(1.0, tk.END)
            w.Text_sendmsg.insert(tk.END, "附件栏已添加一个附件:%s.%s，点击发送按钮即可发送\n" % (fname, form))

    else:
        showinfo("提示", "本功能仅当发送类型为file时可用！")

def btn_showhide():
    show = w.TCombobox_pwd.cget("show")
    if show == "*":
        w.TCombobox_pwd.configure(show="")
        w.Button_showhide.configure(text='''隐藏''')
        w.Button_showhide.configure(background="#000000")
    else:
        w.TCombobox_pwd.configure(show="*")
        w.Button_showhide.configure(text='''显示''')
        w.Button_showhide.configure(background="#00BFFF")

def btn_softinfo():
    showinfo("软件信息", "当前客户端软件版本号: v1.6\nmade by dashen on 2019/06/12 \nQQ 434857005")

def start_connect(client_id="达神", ip="47.93.30.53", port=1883, username="dashen", pwd="123456", sl="tcp"):
    global client
    client = mqtt.Client(client_id, transport=sl)
    client.username_pw_set(username, pwd)
    client.on_connect = on_connect  # 打印连接状态
    try:
        client.connect(ip, port, 60)  # 开始连接
        global xc1
        xc1 = Thread(target=client.loop_forever)  # 开启客户端阻塞线程
        xc1.setDaemon(True)
        xc1.start()  # 线程启动
    except ConnectionRefusedError:
        showinfo("提示", "连接失败！\n请检查该服务器ip是否正常\n目标ip：%s" % ip)
    # global xc2
    # xc2 = Thread(target=sendtest) #循环发送消息。
    # xc2.setDaemon(True)
    # xc2.start()

def on_connect(client, userdata, flags, rc):  # 连接初始化函数。连接成功立即开始订阅并启动消息回调函数
    print("Connected with result code " + str(rc))  # 打印连接状态
    global connect_flag
    if rc == 0 and connect_flag == False:
        print("已成功连接mqtt服务器!")
        showinfo("连接提示", "已成功连接服务器!")
        connect_flag = True
        w.Button_connect.configure(background="#78C300")
        w.Button_connect.configure(text='''断开连接''')
        w.Button_publish.configure(state="normal")
        w.Button_addsub.configure(state="normal")
        w.Button_cancelsub.configure(state="normal")
        w.Button_clearsub.configure(state="normal")
    elif rc != 0 and connect_flag == False:
        print("连接失败，请检查服务器连接设置是否正确!")
        showerror("连接提示", "连接失败!错误码 %s\n请检查服务器连接设置是否正确!")
    else:
        disconnect("由于你向服务器发送的数据超过最大限制\n或者和你同一个设备在其他地方登陆\n你已经被挤掉线!")

def on_publish(topic, payload, qos):  # 发送函数
    """
    :param topic: 消息主题
    :param payload: 消息内容
    :param qos: 连接质量
    :return:
    """
    global client
    client.publish(topic, payload, qos)

def on_subscribe(topic="/data/#", qos=0):  # 订阅函数
    global client
    client.subscribe(topic, qos)  # 订阅通常的
    client.on_message = on_message  # 消息到来处理函数
    print("成功订阅主题: \"%s\",服务质量: %s" % (topic, qos))
    w.Scrolledtext1.insert(tk.END, "成功订阅主题: \"%s\",服务质量: %s \n" % (topic, qos))

def Unsub(topic="/data/#"):
    global client
    client.unsubscribe(topic)

def on_message(client, userdata, msg):  # 订阅消息收到后的回调函数
    msg_display = msg.payload.decode('utf-8')
    print("收到一条来自订阅主题 %s 的信息:    %s" % (msg.topic, msg_display))  # 打印接受的消息
    # global write_data
    # filecode = write_data
    # # print(filecode)
    # if filecode.startswith("filecode"):
    if not msg_display.startswith("filecode") and not msg_display.startswith("luyincode"):
        w.Scrolledtext1.insert(tk.END, "收到一条来自订阅主题 %s 的信息:    %s\n" % (msg.topic, msg_display))
        absp = os.path.abspath('res/msg.wav')
        if os.path.exists(absp):
            print(absp)
            if tch44.get() == "1":
                thread_it(playaudio, absp)
            def start_msg():
                if tch58.get() == "1":  # 判断开启了消息语言通知
                    absp = os.path.abspath('res/msg_txt.wav')
                    print(absp)
                    yinyuehelper("收到一条来自订阅主题 %s 的信息:    %s\n" % (msg.topic, msg_display))
                    global yuyinset_dict
                    # start_t2a(yuyinset_dict["语速"],yuyinset_dict["语调"],yuyinset_dict["音量"],yuyinset_dict["发音人"])  # 开始文字转语音最终生成wav文件
                    # showinfo("提示", "start_t2a")
                    # playaudio1()  # 播放
                    # showinfo("提示", "playaudio1")
                    # playsound("res/msg_txt.mp3")  # 播放任意格式
                    # temp = "res/msg_txt%s.mp3"%(randint(0,999999))
                    nowtime = time.strftime('%Y%m%d%H%M%S', time.localtime(time.time()))
                    temp = r"res/msg_txt_%s.mp3" % nowtime
                    start2andplay(yuyinset_dict["语速"], yuyinset_dict["语调"], yuyinset_dict["音量"], yuyinset_dict["发音人"],
                                  path=temp)

            thread_it(start_msg)
    elif msg_display.startswith("luyincode"):
        thread_it(saveRun,msg_display) #收到消息立即开线程保存声音并播放
        # saveRun(msg_display) #收到消息立即开线程保存声音并播放
    else:
        filename = msg_display.split('"')[0].split("@")[1]
        filetend = msg_display.split('"')[0].split("@")[2].replace("=", "").replace(" ", "")
        # print(filetend)
        filecontent = msg_display.split(" ")[2]
        # print(filecontent)
        w.Scrolledtext1.insert(tk.END, "收到一个来自%s的附件:%s.%s,现在可以将它保存到本地,避免被下个文件覆盖！\n" % (msg.topic, filename, filetend))
        global write_data
        write_data = msg_display
        absp = os.path.abspath('res/msg.wav')
        if os.path.exists(absp):
            print(absp)
            thread_it(playaudio, absp)

            def start_msg():
                if tch58.get() == "1":  # 判断开启了消息语言通知
                    absp = os.path.abspath('res/msg_txt.wav')
                    print(absp)
                    showinfo("提示", "12345")
                    yinyuehelper("收到一个来自%s的附件:%s.%s,现在可以将它保存到本地,避免被下个文件覆盖！\n" % (msg.topic, filename, filetend))
                    global yuyinset_dict
                    # start_t2a(yuyinset_dict["语速"], yuyinset_dict["语调"], yuyinset_dict["音量"],yuyinset_dict["发音人"])  # 开始文字转语音最终生成wav文件
                    # playaudio1()  # 播放wav
                    # playsound("res/msg_txt.mp3")  # 播放任意格式
                    nowtime = time.strftime('%Y%m%d%H%M%S', time.localtime(time.time()))
                    temp = r"res/msg_txt_%s.mp3" % nowtime
                    start2andplay(yuyinset_dict["语速"], yuyinset_dict["语调"], yuyinset_dict["音量"], yuyinset_dict["发音人"],
                                  path=temp)

            thread_it(start_msg)

def btn_connect():
    global connect_flag
    if not connect_flag:
        clinetname = entrytv_clientname.get()
        clinetid = entrytv_clientid.get()
        servertype = combobox_servertype.get()
        mqsl = combobox_mqsl.get()
        mqip = combobox_mqip.get()
        mqport = int(combobox_mqport.get())
        username = combobox_username.get()
        pwd = combobox_pwd.get()
        json = {"clinetname": clinetname, "clinetid": clinetid, "servertype": servertype, "mqsl": mqsl, "mqip": mqip,
                "mqport": mqport, "username": username, "pwd": pwd}
        print(json)
        start_connect(clinetid, mqip, mqport, username, pwd, mqsl)
    else:
        disconnect()

def disconnect(text=""):
    global client, connect_flag
    btn_clearsub()
    client.disconnect()
    client.loop_stop()
    print("已断开与服务器的连接")
    w.Button_connect.configure(text='''开始连接''')
    w.Button_connect.configure(background="#00BFFF")
    w.Button_publish.configure(state="disabled")
    w.Button_addsub.configure(state="disabled")
    w.Button_cancelsub.configure(state="disabled")
    w.Button_clearsub.configure(state="disabled")
    showinfo("连接提示", "已断开与服务的连接！\n%s" % text)
    connect_flag = False

def btn_temp():
    print('dashenMQ_support.btn_temp')
    sys.stdout.flush()

def btn_tianqi():
    global timer_dict
    if not "tqtimer" in timer_dict:
        timer_dict["tqtimer"] = False
    flag = timer_dict["tqtimer"]
    print("按钮按下前tqtimer启用状态:{}".format(flag))
    if not flag:  # 判断当前未开启天气推送
        def start():
            print(time.strftime('%Y-%m-%d %H:%M:%S'))

        w.Button_tq.configure(text='''停止天气推送''')
        w.Button_tq.configure(background="#78C300")
        area = combobox_area.get()
        sec = int(combobox_tqtime.get())
        print("开始以%d秒一次的频率监控并推送%s地区的天气" % (sec, area))
        setinterval(start, sec, "tqtimer")
    else:
        w.Button_tq.configure(text='''开启天气推送''')
        w.Button_tq.configure(background="#00BFFF")
        clearinterval("tqtimer")

def settimeout(func, sec):
    def inner():
        func()
        Timer(sec, inner).start()

    thread_it(inner)

def setinterval(func, sec, tmrname, flag=True):
    global timer_dict
    timer_dict[tmrname] = flag
    print("已设置tqtimer启用状态为:{}".format(flag))

    def inner():
        global timer_dict
        if timer_dict[tmrname]:
            func()
            Timer(sec, inner).start()

    thread_it(inner)

def clearinterval(timername):
    global timer_dict
    timer_dict[timername] = False
    flag = timer_dict[timername]
    print("已设置tqtimer启用状态为:{}".format(flag))

def btn_settemp():
    print('dashenMQ_support.btn_settemp')
    sys.stdout.flush()

def btn_news():
    print('dashenMQ_support.btn_news')
    sys.stdout.flush()

def btn_exit():
    exit_flag = (askquestion("退出提示", "确认彻底关闭软件?") == "yes")
    print(exit_flag)
    if exit_flag:
        destroy_window()

def iconset(top):
    global res_dict
    img = res_dict["logo.ico"]
    tmp = open("res/tmp.ico", "wb+")
    tmp.write(base64.b64decode(img))
    tmp.close()
    top.iconbitmap('res/tmp.ico')
    os.remove("res/tmp.ico")  # 删掉临时文件

def load_res():
    global res_dict
    res_dict = {}
    res_dict["logo.ico"] = myres.img
    res_dict["audio.mp3"] = myres.qqaudio
    res_dict["msg.wav"] = myres.qqmsg
    res_dict["PyAudio-0.2.11-cp37-cp37m-win32.whl"] = myres.pyaudiowheel32
    res_dict["资源无损编码储存.py"] = myres.basefiletool
    res_dict["一键打包exe.py"] = myres.py2exe
    res_dict["音乐格式转换.py"] = myres.mp3towav
    res_dict["百度语音引擎.py"] = myres.baiduaudio
    res_dict["pip安装引擎.py"] = myres.fastpiptool
    res_dict["git单文件下载器.py"] = myres.git_helper
    res_dict["txt2audio.wav"] = myres.txt2audio
    if not os.path.exists("res"):
        os.mkdir("res")
    if not os.path.exists("res/luyin"):
        os.mkdir("res/luyin")
    for key in res_dict:
        if not os.path.exists("res/%s" % key):
            tmp = open("res/%s" % key, "wb+")
            tmp.write(base64.b64decode(res_dict[key]))
            tmp.close()
            print("成功写入:%s" % key)
    a = showsystem()
    print(a)
    pypath = sys.executable
    print(pypath)
    try:
        global pyadplay
        import pyaudio
        pyadplay = pyaudio
        # p = os.popen("ipconfig")
        # print(p.read())  # 执行cmd并得到返回的字符串
        # absp = os.path.abspath('res/PyAudio-0.2.11-cp37-cp37m-win32.whl')
        # print(absp)
        # pypath = sys.executable
        # p = os.popen("%s -m pip install %s" % (pypath, absp))
        # print(p.read())  # 执行cmd并得到返回的字符串
    except ModuleNotFoundError:
        absp = os.path.abspath('res/PyAudio-0.2.11-cp37-cp37m-win32.whl')
        print(absp)
        pypath = sys.executable
        print(pypath)
        p = os.popen("%s -m pip install %s" % (pypath, absp))
        try:
            print(p.read())  # 执行cmd并得到返回的字符串
        except UnicodeDecodeError:
            print("读取返回值失败，大概意思是编码不对，但是已经安装成功了")

        try:
            import pyaudio
            pyadplay = pyaudio
        except:
            print("安装pyaudio库存在问题，音乐播放未能启用\n请手动解决问题")
    # absp = os.path.abspath('.')
    # print(absp)
    # resp = os.path.relpath(absp)
    # print(resp)
    # p = os.popen("ipconfig")
    # print(p.read())#执行cmd并得到返回的字符串
    # p = get_filePath_fileName_fileExt("res/pyaudiowheel32.whl")
    # print(p)
    # a = platform.platform()
    # a = platform.uname()

def playaudio(audio_file):
    global pyadplay
    chunk = 1024  # 2014kb
    wf = wave.open(audio_file, 'rb')
    p = pyadplay.PyAudio()
    stream = p.open(format=p.get_format_from_width(wf.getsampwidth()), channels=wf.getnchannels(),
                    rate=wf.getframerate(), output=True)
    while True:
        data = wf.readframes(chunk)
        if len(data) == 0:
            break
        else:
            # print(data)
            stream.write(data)
    stream.stop_stream()  # 停止数据流
    stream.close()
    p.terminate()  # 关闭 PyAudio
    # print('wav音乐播放play函数结束！')

def getclientinfo():
    a = platform.node()
    b = platform.architecture()
    now = time.strftime('%M:%S', time.localtime(time.time()))
    c = "达神MQ_" + b[1] + "-" + a + "_" + now
    print(c)
    return c

def btn_setupyuyin():
    print("音乐助手已启用，现检查本地语音助手文件是否存在...")
    exit_yuyin1 = os.path.exists("ffmpeg.exe")
    exit_yuyin2 = os.path.exists("ffplay.exe")
    exit_yuyin3 = os.path.exists("ffprobe.exe")
    print("本地语音组件1:%s,语音组件2：%s,语音组件3:%s" % (exit_yuyin1, exit_yuyin2, exit_yuyin3))
    list_xiazai.set("本地语音组件1:%s\n语音组件2：%s\n语音组件3:%s" % (exit_yuyin1, exit_yuyin2, exit_yuyin3))
    if not exit_yuyin1:
        thread_it(download, 'https://raw.githubusercontent.com/hjdhnx/soundhelper/master/ffmpeg.exe')
        # download('https://raw.githubusercontent.com/hjdhnx/soundhelper/master/ffmpeg.exe')
    if not exit_yuyin2:
        thread_it(download, 'https://raw.githubusercontent.com/hjdhnx/soundhelper/master/ffplay.exe')
        # download('https://raw.githubusercontent.com/hjdhnx/soundhelper/master/ffplay.exe')
    if not exit_yuyin3:
        thread_it(download, 'https://raw.githubusercontent.com/hjdhnx/soundhelper/master/ffprobe.exe')
        # download('https://raw.githubusercontent.com/hjdhnx/soundhelper/master/ffprobe.exe')

def yuyinhelper_jiance():
    if tch58.get() == "1":
        btn_setupyuyin()

def btn_readyuyinset():
    print('dashenMQ_new_support.btn_readyuyinset')
    sys.stdout.flush()

def btn_phone():
    if w.Button_connect.cget("text")=="开始连接":
        showwarning("警告","请先连接mqtt服务器后再进行操作！")
        return
    global tonghua_flag
    if w.Button_phone.cget("text")=="开启通话":
        tonghua_flag = True
        w.Button_phone.configure(text='''停止通话''')
        w.Button_phone.configure(background='''red''')
        # thread_it(luying)
        def dingshiyulin():
            luyin()
            def now():
                topic = varperson.get()
                payload = baseluyin()
                qos = 0
                on_publish(topic, payload, qos)
                # print(topic,payload)
                # saveRun(a)
            thread_it(now)
        setinterval(dingshiyulin,0.1,"定时录音")
    else:
        tonghua_flag = False
        w.Button_phone.configure(text='''开启通话''')
        w.Button_phone.configure(background='''#78C300''')
        global timer_dict
        timer_dict["定时录音"] = tonghua_flag
def baseluyin(inputpath="res/luyin/output.wav",outputpath="res/luyin/luyinfilecode.txt"):
    if inputpath != "":
        _, fname, tp1 = get_filePath_fileName_fileExt(inputpath)
        form = tp1[1:]
        print(form)  # 打印文件类型
        open_file = open(inputpath, "rb")
        b64str = base64.b64encode(open_file.read())
        open_file.close()
        sendfile = f'luyincode@{fname}@{form} = "{b64str}"'
        sendfile = sendfile.replace("b'", "").replace("'", "")
        f = open(outputpath, "w+")
        f.write(sendfile)
        f.close()
        return sendfile
def saveRun(luyincode):
    if luyincode.startswith("luyincode"):
        filename = luyincode.split('"')[0].split("@")[1]
        filetend = luyincode.split('"')[0].split("@")[2].replace("=", "").replace(" ", "")
        filecontent = luyincode.split(" ")[2]
        savepath = f"res/luyin/received{filename}.{filetend}"
        tmp = open(savepath, "wb+")
        tmp.write(base64.b64decode(filecontent))
        tmp.close()
        print(f"成功写入:{savepath}")
        playaudio(savepath)

def luyin(path="res/luyin/output.wav",long=0.5):
    CHUNK = 1024
    FORMAT = pyaudio.paInt16
    CHANNELS = 2
    RATE = 44100
    RECORD_SECONDS = long # 设置录音的时间长度,单位秒
    WAVE_OUTPUT_FILENAME = path
    p = pyaudio.PyAudio()
    stream = p.open(format=FORMAT,channels=CHANNELS,rate=RATE,input=True,frames_per_buffer=CHUNK)
    # print("* 录音开始")
    frames = []
    for i in range(0, int(RATE / CHUNK * RECORD_SECONDS)):
        data = stream.read(CHUNK)
        frames.append(data)
    stream.stop_stream()
    stream.close()
    p.terminate()
    def end():
        wf = wave.open(WAVE_OUTPUT_FILENAME, 'wb')
        wf.setnchannels(CHANNELS)
        wf.setsampwidth(p.get_sample_size(FORMAT))
        wf.setframerate(RATE)
        wf.writeframes(b''.join(frames))
        wf.close()
        # print("* 录音结束")
    end()

def saveyuyinset():
    spd = int(spinbox_setspd.get())
    pit = int(spinbox_setpit.get())
    vol = int(spinbox_setvol.get())
    per = int(spinbox_setper.get())
    global yuyinset_dict
    yuyinset_dict = {"语速": spd, "语调": pit, "音量": vol, "发音人": per}
    print(yuyinset_dict)

def btn_saveyuyinset():
    saveyuyinset()
    global yuyinset_dict
    showinfo("提示", "成功保存数据！\n{}".format(yuyinset_dict))

def btn_uninstallyuyin():
    xiezai_flag = askokcancel("卸载确认", "你确定要卸载语音助手吗?")
    if xiezai_flag:
        # file_list=["res/ffmpeg.exe","res/ffplay.exe","res/ffprobe.exe"]
        file_list = ["ffmpeg.exe", "ffplay.exe", "ffprobe.exe"]
        for i in file_list:
            if os.path.exists(i):
                os.remove(i)
        showinfo("提示", "语音助手卸载完毕!")

def download(url):
    try:
        global myrequest
        import requests
        myrequest = requests
    except ModuleNotFoundError:
        absp = "requests"
        print(absp)
        pypath = sys.executable
        print(pypath)
        p = os.popen("%s -m pip install %s" % (pypath, absp))
        try:
            print(p.read())  # 执行cmd并得到返回的字符串
        except UnicodeDecodeError:
            print("读取返回值失败，大概意思是编码不对，但是已经安装成功了")
        try:
            import requests
            myrequest = requests
        except:
            print("安装requests库存在问题，下载器未能启用\n请手动解决问题")
    filepath, shotname, extension = get_filePath_fileName_fileExt(url)
    # filename = "res/"+shotname+extension
    filename = shotname + extension
    print(filepath, filename)
    if not os.path.exists(filename):
        print("当前目录不存在该文件，尝试下载此文件")
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"}
        with closing(myrequest.get(url, headers=headers, stream=True)) as response:
            chunk_size = 1024  # 单次请求最大值
            content_size = int(response.headers['content-length'])  # 内容体总大小
            data_count = 0
            with open(filename, "wb") as file:
                for data in response.iter_content(chunk_size=chunk_size):
                    file.write(data)
                    data_count = data_count + len(data)
                    now_jd = (data_count / content_size) * 100

                    def show(shotname):
                        global xiazai_dict
                        xiazai_dict[shotname] = "文件下载进度：%d%%(%d/%d)\n-%s" % (now_jd, data_count, content_size, filename)
                        listtext = xiazai_dict["ffmpeg"] + "\n" + xiazai_dict["ffplay"] + "\n" + xiazai_dict["ffprobe"]
                        # print("\r "+listtext, end=" ")
                        # thread_it(list_xiazai.set,listtext)
                        list_xiazai.set(listtext)
                        tpb_send.set("%s" % now_jd)
                        labletv_jindu.set('%.2f%%' % now_jd)

                    # show(shotname)
                    thread_it(show, shotname)
    else:
        print("文件%s已存在，无需重复下载" % filename)

def yinyuehelper(text="达神互联 MQTT客户端 启动成功。 接下来 你可以进行连接设置。 然后开始连接， 再添加订阅需要的主题， 或者发布主题。"):
    try:
        from aip import AipSpeech
    except:
        pipsetup("baidu-aip")
        from aip import AipSpeech
    file_object = None
    aipSpeech = None

    def default_init(text):
        APP_ID = '16427879'
        API_KEY = 'H1OOrfrsKCjZruv8SvWn3MHw'
        SECRET_KEY = 'we2ppcpEQi5Qj4lMvIZG1fCcMo6ztYaF '
        global aipSpeech
        aipSpeech = AipSpeech(APP_ID, API_KEY, SECRET_KEY)
        f = open("res/audiofile.txt", "w+")
        # text = "《我们都是追梦人》 。\
        #             作曲 : 常石磊。\
        #             作词 : 王平久，编曲 : 柒玖、于昊。\
        #             每个身影 同阳光奔跑。 \
        #             我们挥洒汗水 回眸微笑。\
        #             一起努力 争做春天的骄傲。\
        #             懂得了梦想，越追越有味道。\
        #             我们都是追梦人，千山万水 奔向天地跑道。\
        #             你追我赶 风起云涌春潮，海阔天空 敞开温暖怀抱，我们都是追梦人，在今天 勇敢向未来报到。\
        #             当明天 幸福向我们问好，最美的风景是拥抱。\
        #             啦……啦……啦……。\
        #             每次奋斗 拼来了荣耀。\
        #             我们乘风破浪 举目高眺。"
        text = text
        # text = "朕四岁步入《修真世界》，五岁修《道》，六岁练神功《真灵九变》，历经《九劫》终于在十四岁将此功练至大成，从此《声名鹊起》，无人不知，十五岁得《神印王座》，十八岁得《帝尊》传承，从此《独步天下》，堪称《一代天骄》，因杀人过多，《血染一生》，被世人称为《杀神》，然而《神道》漫长。修炼永无止境，朕与《六道仙尊》，《大道主》，《玄帝》，《剑祖》等人乘《灵舟》《武破九霄》至《斗罗大陆》，创立《绝世唐门》。机缘巧合之下，在《神魔练兵场》的一座《血染的图腾》下面，发现《武墓》，得到《武神》传承。得其成名绝技《宇宙本源决》，欲《斗破苍穹》，《吞噬星空》，一手《遮天》。后来误入《长生界》，闯下弥天大祸，被《圣王》知道，带领《战尊》，《龙血战神》，《异世邪君》，《狂神》，又从《龙族》请来数位仙道高手，从《灵域》，而来，与朕在《战天大陆》展开《惊世大战》，《九死一生》，终将尔等斩杀，然《天道无情》，趁朕重伤之下偷袭朕，降下《血天劫》，幸得《善良的死神》相助，朕且苟延残喘，后于《神墓》中走出，自创两大神功《星辰变》，《九星天辰诀》，世人皆知，终成《绝世武神》。从此《傲世九重天》，建立《大周皇朝》，得《永生》。欲开创《莽荒纪》元，统一《完美世界》。朕资质平平，却《百炼成仙》，被人称为《圣皇》。朕之经历当用五字表达————《凡人修仙传》"
        f.write(text)
        f.close()
        global file_object
        file_object = open('res/audiofile.txt')

    default_init(text)

def playaudio1(audio_file="res/msg_txt.wav"):
    global pyadplay
    import pyaudio
    pyadplay = pyaudio
    chunk = 1024  # 2014kb
    wf = wave.open(audio_file, 'rb')
    p = pyadplay.PyAudio()
    stream = p.open(
        format=p.get_format_from_width(
            wf.getsampwidth()),
        channels=wf.getnchannels(),
        rate=wf.getframerate(),
        output=True)
    data = wf.readframes(chunk)  # 读取数据
    while True:
        data = wf.readframes(chunk)
        if len(data) == 0:
            break
        else:
            # print(data)
            stream.write(data)
    stream.stop_stream()  # 停止数据流
    stream.close()
    p.terminate()  # 关闭 PyAudio
    # print('wav音乐播放play函数结束！')

def start_t2a(spd=5, pit=5, vol=5, per=3, convert=False, path=r"res/msg_txt.mp3"):
    """

    :param spd: 合成语音的讲话速度
    :param pit: 合成语言的讲话音调
    :param vol: 合成语言的音量
    :param per: 发音人选择, 0为普通女声，1为普通男生，3为情感合成-度逍遥，4为情感合成-度丫丫,5为情感合成-小琪琪，默认为情感合成-度逍遥
    :return:
    """
    global file_object, aipSpeech
    try:
        n = file_object.read()
        print(n)
    finally:
        file_object.close()
    result = aipSpeech.synthesis(n, 'zh', 1, {'spd': spd, 'pit': pit,
                                              'vol': vol, 'per': per,
                                              })
    print(result)
    if not isinstance(result, dict):
        # with open('res/msg_txt.mp3', 'wb') as f:
        f = open(path, 'wb')
        f.write(result)
        if convert:
            starttool(path, "msg_txt.wav")
            print("音乐转换完毕！")
        f.close()
    else:
        print("音乐合成结果错误")

def start2andplay(spd=5, pit=5, vol=5, per=3, convert=False, path="res/msg_txt.mp3"):
    start_t2a(spd=spd, pit=pit, vol=vol, per=per, convert=convert, path=path)
    playsound(path)
    del_flag = varcheck_delyuyin.get()
    if del_flag == "1":
        try:
            count = activeCount()
            print("当前总线程数量:%s" % count)
            os.remove(path)
        except:
            print("文件路径被占用，不允许删除")

def pipsetup(packname):
    pypath = sys.executable
    print(pypath)
    packcmd = "%s -m pip install %s" % (pypath, packname)
    try:
        p = os.popen(packcmd)
    except UnicodeDecodeError:
        print("返回文本的格式编码有问题！")
    try:
        print(p.read())  # 执行cmd并得到返回的字符串
    except UnicodeDecodeError:
        print("读取返回值失败，大概意思是编码不对，不过已经执行完毕了")

def starttool(mp3path, output, form="wav"):
    # if os.path.exists("ffmpeg.exe") and os.path.exists("ffplay.exe") and os.path.exists("ffprobe.exe"):
    if os.path.exists("ffmpeg.exe") and os.path.exists("ffprobe.exe"):  # 音乐转码至少需要这么两个
        try:
            from pydub import AudioSegment
            # showinfo("提示", "导入pydub没报错")
        except BaseException:
            print("本地不存在音乐处理支持库，开始安装pydub...")
            # showinfo("提示", "本地不存在音乐处理支持库，开始安装pydub...")
            pipsetup("pydub")
            from pydub import AudioSegment

        # AudioSegment.converter = r"D:\ffmpeg\bin\ffmpeg.exe"

        def trans_mp3_to_wav(mp3path=mp3path, output=output, form=form):
            if os.path.exists(mp3path):
                try:
                    # absp = os.path.abspath('res/ffmpeg.exe')
                    # absp1 = os.path.abspath('res/ffprobe.exe')
                    # AudioSegment.converter = absp
                    # song = AudioSegment.from_mp3(mp3path)
                    song = AudioSegment.from_file(mp3path, format='MP3')
                    song.export("res/%s" % output, format=form)
                except:
                    tch58.set("0")
                    showinfo("提示", "由于打包程序时没有带控制台或其他异常，\n导致无法正常转换使用ffmpeg.exe工具\n已自动关闭语音助手消息转换，如需启用请检查文件存在后再手动")
            else:
                print("目标文件不存在!")

        trans_mp3_to_wav()

    else:
        csdn_url = "https://blog.csdn.net/qq_32394351/article/details/90748900"
        ext_mpeg = os.path.exists("ffmpeg.exe")
        ext_play = os.path.exists("ffplay.exe")
        ext_probe = os.path.exists("ffprobe.exe")
        print("请至少将ffmpeg.exe,ffprobe.exe程序放到本文件同目录后再执行！")
        print("不会操作请访问作者csdn教程查看：%s" % csdn_url)
        print(
            "文件检测:必须： ffmpeg.exe:%s,ffprobe.exe:%s,非必须:ffplay.exe:%s," %
            (ext_mpeg, ext_probe, ext_play))

def yuyin_reset():
    global spinbox_setspd
    spinbox_setspd.set(5)
    global spinbox_setpit
    spinbox_setpit.set(5)
    global spinbox_setvol
    spinbox_setvol.set(5)
    global spinbox_setper
    spinbox_setper.set(4)
    global spinbox_luyintime
    spinbox_luyintime.set(4)
def yuyinhelper():
    print(tch58.get())

def init(top, gui, *args, **kwargs):
    load_res()
    global w, top_level, root, write_data, xc1, sendfile, connect_flag, timer_dict
    global xiazai_dict
    xiazai_dict = {"ffmpeg": "ffmepeg文件下载进度已完成", "ffplay": "ffplay文件下载进度已完成", "ffprobe": "ffprobe文件下载进度已完成"}
    global yuyinset_dict
    yuyinset_dict = {"语速": 5, "语调": 5, "音量": 5, "发音人": 4}
    w = gui
    top_level = top
    root = top
    write_data = ""
    sendfile = ""
    timer_dict = {}
    connect_flag = False
    top.resizable(False, False)  # 禁止窗口可拉伸
    w.Button_publish.configure(state="disabled")
    w.Button_addsub.configure(state="disabled")
    w.Button_cancelsub.configure(state="disabled")
    w.Button_clearsub.configure(state="disabled")
    w.Scrolledtext1.configure(wrap="char")
    yuyin_reset()
    iconset(top)
    client_id = getclientinfo()
    entrytv_clientid.set(client_id)

    saveyuyinset()  # 初始化语音设置，接调用保存设置的按钮功能

    # absp = os.path.abspath('res/msg.wav')
    # print(absp)
    # thread_it(playaudio,absp)

    # obsp = "res/audio.mp3"
    obsp = "res/txt2audio.wav"
    # thread_it(playsound, obsp)
    thread_it(playaudio, obsp)

    # btn_randomgerner()
    # print(w.TProgressbar1.keys())
    # for i in w.TProgressbar1.keys():
    #     print(w.TProgressbar1.cget(i))

def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    import dashenMQ_new
    dashenMQ_new.vp_start_gui()




